## 1.变量提升

当 JavaScript 编译所有代码时，所有使用 var 的变量声明都被提升到它们的函数/局部作用域的顶部(如果在函数内部声明的话)，或者提升到它们的全局作用域的顶部(如果在函数外部声明的话)，而不管实际的声明是在哪里进行的。这就是我们说说的"提升"。

这种"提升"实际上并不发生在你的代码中，而只是一种比喻，与 JavaScript 编译器如何读取你的代码有关。记住当我们想到"提升"的时候，我们可以想象任何被提升的东西都会被移动到顶部，但是实际上你的代码并不会被修改。

函数声明也会被提升，但是被提升到了最顶端，所以将位于所有变量声明之上。

在编译阶段变量和函数声明会被放入内存中，但是你在代码中编写它们的位置会保持不变。

## 2.闭包的缺点是什么？闭包的应用场景有哪些？怎么销毁闭包？

闭包是指有权访问另外一个函数作用域中的变量的函数。

因为闭包引用着另一个函数的变量，导致另一个函数已经不使用了也无法销毁，所以闭包使用过多，会占用较多的内存，这也是一个副作用，内存泄漏。

如果销毁一个闭包，可以把被引用的变量设置为 null。即手动清除变量，这样下次 js 垃圾回收机制回收时，就会把设为 null 的变量给回收了。

闭包的应用场景：  
1.匿名自执行函数  
2.结果缓存  
3.封装  
4.实现类和继承

## 3.js 垃圾回收机制

js 具有自动垃圾回收机制。垃圾收集器会按照固定的时间间隔周期性的执行。

js 常见的垃圾回收方式：标记清除、引用计数方式。

**标记清除方式：**

- 工作原理：当变量进入环境时，将这个变量标记为"进入环境"。当变量离开环境时，则将其标记为"离开环境"。标记"离开环境"的回收内存。
- 工作流程：
- 垃圾回收器：在运行的时候会给存储在内存中的所有变量都加上标记；
- 去掉环境中的变量以及被环境的变量引用的变量的标记；
- 被加上标记的会被视为准备删除的变量；
- 垃圾回收器完成内存清理工作，销毁那些标记的值并回收他们所占的内存空间。

**引用计数方式：**

- 工作原理：跟踪记录每个值被引用的次数。
- 工作流程：
- 声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是 1；
- 同一个值又被赋值给另一个变量，这个引用类型值的引用次数加 1；
- 当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型的引用次数减 1；
- 当引用次数变成 0 时，说明没办法访问这个值了；
- 当垃圾收集器下一次运行时，他就会释放引用次数为 0 的值所占的内存。
