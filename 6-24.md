# 6.24 任务

## 1.vue 的路由实现

## 解释 hash 模式和 history 模式的实现原理：

#后面的 hash 值的变化不会导致浏览器向服务器发出请求，浏览器不发出请求，就不会刷新页面。通过监听 hashchange 事件的变化可以知道 hash 值发生了哪些变化，然后根据 hash 值的变化来实现更新页面部分内容的操作

history 模式的实现主要是通过 HTML5 标准发布的两个 api，pushstate 和 replacestate。这两个 api 可以改变 url，但不会发出请求。这样可以监听 url 的变化来实现页面部分内容的更新。

hash 模式和 history 模式的区别主要有：  
1.首先是 url 的展示上 hash 有#而 history 没有  
2.刷新页面时，hash 模式可以加载 hash 值对应的页面；history 模式下如果没有处理，则会返回 404，一般需要后端对所有页面配置重定向到首页路由。
3.hash 可以兼容低版本的浏览器以及 ie

## 2.vuex 是什么？怎么使用它？什么场景下我们会使用到 vuex？

vuex 是专为 vue 应用程序开发的一个状态管理器，采用集中式存储管理应用的所有组件的状态。每一个 vuex 的核心就是一个 store。store 基本上就是一个容器，它包含着应用中大部分的状态 state。

在 main.js 中引入 vuex，注入。只用来读取的状态集中放在 store 中，改变状态的方式是提交 mutations，这是个同步的事物，异步逻辑应该封装在 action 中。

如果是 vue 的小型应用则没有必要使用 vuex，这个时候使用 vuex 反而会带来负担，可以通过 props，自定义事件来进行状态传递。
但是如果涉及到 vue 的大型应用。则需要使用类似于 vuex 这样的集中状态的状态机来管理所有组件的状态。

## 3.说一下 v-if 和 v-show 的区别

共同点：都是动态地显示 dom 元素
区别：
**手段不同**：
v-if 是动态地向 dom 树内添加或者删除 dom 元素
v-show 是通过 dom 元素 display 样式属性控制显隐
**编译过程不同**：
v-if 切换有一个局部编译/卸载的过程，在切换过程中合适的销毁和重建内部的事件监听和子组件
v-show 只是简单的基于 css 样式切换
**编译条件不同**：
v-if 是惰性的，如果初始条件为假，则什么都不做，只有条件在第一次为真时，才开始局部编译
v-show 在任务条件下都被编译，然后被缓存，而且 dom 元素保留
**性能消耗不同**：
v-if 有更高的切换消耗
v-show 有更高的初始渲染消耗
**适用场景不同**：
v-if 适合运营条件不大可能改变的场景
v-show 适合频繁切换的场景

## 4.如何让 css 值在当前的组件中起作用

在 vue 文件中的 style 标签上，有一个特殊的样式属性：scoped。当一个 style 标签拥有 scoped 属性时，它的 css 样式就只能相当于当前的组件，也就是说，该样式只能适用于当前组件元素。通过元素组件，可以使得组件之间的样式不互相污染。如果一个项目中的所有 style 都加上 scoped，相当于实现了样式的模块化。

## 5.keep-alive 相关

keep-alive 组件是 vue 的内置组件。用于缓存内部组件实例。这样做的目的在于，keep-alive 内部的组件切回时，不用重新创建组件实例，而是使用缓存中的组件实例，一方面可以避免创建组件带来的开销，一方面可以保留组件状态。

keep-alive 有 include 和 exclude 两个属性，可以控制哪些组件实例可以进入缓存。另外他还有一个 max 属性，可以设置最大的缓存数，当缓存的组件实例超过该数时，vue 会移最久没有使用的组件缓存。

## 6.vue 中如何进行组件的使用？vue 如何实现全局组件的注册？

要使用组件，首相需要使用 import 来引入组件，然后再 components 属性中注册组件，之后就可以在模板中使用组件了。
可以使用 Vue.components 方法来实现全局组件的注册。

## 7.vue-cli 工程相关

构建 vue-cli 工程都用到了哪些技术？它们的作用分别是什么？
1.vue.js:vue-cli 工程的核心，其特点是双向数据绑定和组件系统
2.vue-router：vue 官方推荐使用的路由框架
3.vuex:专为 vue 应用项目开发的一个状态管理器，主要用于维护 vue 组件之间共用的一些变量和方法。
4.axios：(或者 fetch，ajax)用于发起 get 或 post 等 http 请求，基于 promise 设计
5.vux：专为 vue 设计的移动端 ui 组件库
6.webpack：模块加载以及 vue-cli 打包器
7.eslint：代码规范工具

vue-cli 工程常用的 npm 命令有哪些？
npm install
npm run dev
npm run build
npm run build --report

## 8.nextTick 的作用是什么？它的实现原理是什么

作用：vue 更新 DOM 是异步更新的，数据变化，DOM 的更新不会马上完成，nextTick 的回调是在下次 DOM 更新循环结束之后执行的延迟回调。
实现原理：nextTick 主要使用了宏任务和微任务，根据执行环境不同分别尝试采用：

- Promise：可以将函数延迟到当前函数调用栈的最末端
- MutationObserver：是 H5 新加的一个功能，其功能是监听 DOM 节点的变动，在所有 DOM 变动完成后，执行回调函数
- setimmediate：用于中断长时间运行的操作，并在浏览器完成其他操作(如事件和显示更新)后立即运行回调函数
- 如果以上都不行则采用 settimeout 把函数延迟到 DOM 更新之后再使用

原因是宏任务消耗大于微任务，优先使用微任务，最后使用消耗最大的宏任务。

## 9.说一下 vue ssr 实现原理？

## 10.vue 组件的 data 为什么必须是函数？

组件中的 data 写成一个函数，数据以函数返回值的形式定义。这样每复用一次组件时，就会返回一份新的 data，类似于给每个组件实例创建了一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件公用一份 data，就会造成一个变了全都会变得结果。
