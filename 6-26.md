# 6-26 任务

## 1.vue 中的 SPA 应用如何优化首屏加载速度

请求优化、缓存、gzip 打包、http2、懒加载、预渲染、合理使用第三方库、使用可视化工具分析打包后的模块体积、提高代码使用率、封装、图片懒加载、使用 svg 图标、压缩图片

## 2.移动端如何实现一个比较友好的 header 组件

Header 一般分为左、中、右三部分，分为三个区域来设计，中间为主标题，每个页面的标题肯定不同，所以可以通过 vue props 的方式做成可配置的对外进行暴露，左侧大部分页面可能都是回退按钮，但是样式和内容不尽相同，右侧一般都是具有功能性的操作按钮，所以左右两侧可以通过 vue slot 插槽的方式对外暴露，以实现多样化，同时也可以提供 default slot 默认插槽来统一页面风格

## 3.既然 Vue 通过数据劫持可以精准探测数据变化，为什么还需要虚拟 DOM 进行 diff 监测差异

现代前端框架有两种方式侦测变化，一种是 pull，一种是 push
**pull**：的代表是 React
**push**：
Vue 的响应时系统则是 push 的代表，当 Vue 程序初始化的时候就会对数据 data 进行依赖的收集，一旦数据发生变化，响应式系统就会立刻得知，因此 Vue 是一开始就知道是在哪发生变化了。
但是这又会产生一个新的问题，绑定一个数据就需要一个 Watcher，一旦我们的绑定细粒度过高就会产生大量的 Watcher，这会带来内存以及依赖追踪的开销，而细粒度过低会无法精准侦测变化，因此 Vue 的设计选择中等细粒度的方案，在组件级别进行 push 侦测的方式，也就是那套响应式系统。
通常我们会在第一时间知道发生变化的组件，然后在组件内部进行 Virtual Dom Diff 获取更加具体的差异，而 Virtual Dom Diff 则是 pull 操作，Vue 是 push+pull 结合的方式进行变化侦测的。

## 4.Vue 为什么没有类似 React 中 shouldComponentUpdate 的生命周期

根本原因是 Vue 和 React 的变化侦测方式不同

React 是 pull 的方式侦测变化；
Vue 是 pull+push 的方式侦测变化的，在一开始就知道哪个组件发生了变化，因此在 push 的阶段并不需要手动控制 diff，而组件内部采用的 diff 方式实际上是可以引入类似于 shouldComponentUpdate 相关生命周期的，但是通常合理大小的组件不会有过量的 diff，手动优化的价值有限，因此目前 Vue 并没有考虑引入 shouldComponentUpdate 这种手动优化的生命周期。

## 5.Vue 中的 Key 的作用是什么

**key 的作用主要是为了高效的更新虚拟 DOM**。另外 vue 中使用相同标签名元素的过渡切换时，也会使用到 key 属性，其目的也是为了让 vue 可以区分它们，否则 vue 只会替换其内部属性而不会触发过渡效果。

## 6.你的接口请求一般放在哪个生命周期中？为什么这样做？

接口请求可以放在 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端返回的数据进行赋值。

但是推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：

- 能更快获取到服务端数据，减少页面 loading 时间
- SSR 不支持 beforeMount、mounted 钩子函数，所以放在 created 中有助于代码的一致性。
- created 是在模板渲染成 html 前调用，即通常初始化某些属性，然后再渲染成试图。如果在 mounted 钩子函数中请求数据可能导致页面闪屏问题

## 7.说一下你对 vue 事件绑定原理的理解

vue 中的事件绑定是有两种，一种是原生的事件绑定，另一种是组件的事件绑定。

原生的事件绑定在普通元素上是通过@click 进行绑定，在组件上是通过@click.native 进行绑定，组件中的 nativeOn 等价于 on 的。组件的事件绑定的@click 是 vue 中自定义的 on 方法来实现的，必须有 emit 才可以触发。

**原生的事件绑定原理**
在 runtime 下的 patch.js 中 createPathFunction 执行了之后再赋值给 patch

createPathFunction 方法有两个参数，分别是 nodeOps 存放 dom 节点的方法和 modules，modules 是有两个数组拼接起来的，modules 拼接完的数组中有一个元素是 events，事件添加就发生在这里。

## 8.说一下 vue 模板编译的原理是什么

简单地说，Vue 的编译过程就是将 template 转化为 render 函数的过程。会经历以下阶段：

    - 生成AST树
    - 优化
    - codegen

首先解析模板，生成 AST 语法树(一种用 JavaScript 对象的形式来描述整个模板)。使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。

Vue 的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的 DOM 也不会变化。那么优化过程就是深度遍历 AST 树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的对比，对运行时的模板起到很大的优化作用。

编译的最后一步是将优化后的 AST 树转换为可执行的代码。

## 9.delete 和 Vue.delete 删除数组有什么区别

delete 只是被删除的元素变成了 empty/undefined 其它的元素的键值还是不变
Vue.delete 是直接将元素从数组中完全删除，改变了数组其他元素的键值

## 10.v-on 可以实现监听多个方法吗

可以监听多个方法。关于监听多个方法提供了几种不同的写法：
1.v-on="{事件类型:事件处理函数，事件类型:事件处理函数}"
2.@事件类型="“事件处理函数”" @事件类型="“事件处理函数”"  
3.在一个事件里面书写多个事件处理函数
@事件类型="事件处理函数 1，事件处理函数 2"  
4.在事件处理函数内部调用其它的函数
